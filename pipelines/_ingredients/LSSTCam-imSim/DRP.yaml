description: DRP specialized for ImSim-DC2 data
instrument: lsst.obs.lsst.LsstCamImSim
imports:
  - location: $DRP_PIPE_DIR/pipelines/_ingredients/DRP.yaml
    labeledSubsetModifyMode: EDIT
    exclude:
     - fgcm
     - gbdesAstrometricFit
  # TODO[DM-47010]: inclusion is historical, possibly unintentional (at least
  # for test-med-1; we want it in ci_imsim for test coverage).  If we don't
  # want it in test-med-1, we should move its inclusion to ci_imsim.
  - $ANALYSIS_TOOLS_DIR/pipelines/coaddDiffMatchedQualityExtended.yaml
parameters:
  filterMap: {
    "u": "lsst_u_smeared",
    "g": "lsst_g_smeared",
    "r": "lsst_r_smeared",
    "i": "lsst_i_smeared",
    "z": "lsst_z_smeared",
    "y": "lsst_y_smeared",
  }
  # Bands to match aperture fluxes on as a fallback if cModel failed
  # default is for highest S/N bands to avoid giving equal weight
  # to aperture fluxes vs CModel (which should be better for galaxies)
  bands_match_fallback: ["r", "i"]
tasks:
  isr:
    class: lsst.ip.isr.IsrTask
    config:
      connections.newBFKernel: bfk
      doDefect: false
      doBrighterFatter: true
      # Although we don't have to apply the amp offset corrections, we do want
      # to compute them for analyzeAmpOffsetMetadata to report on as metrics.
      doAmpOffset: true
      ampOffset.doApplyAmpOffset: false
  calibrate:
    class: lsst.pipe.tasks.calibrate.CalibrateTask
    config:
      connections.astromRefCat: "cal_ref_cat_2_2"
      connections.photoRefCat: "cal_ref_cat_2_2"
      python: |
        config.astromRefObjLoader.filterMap = parameters.filterMap
        config.photoRefObjLoader.filterMap = parameters.filterMap
  updateVisitSummary:
    class: lsst.drp.tasks.update_visit_summary.UpdateVisitSummaryTask
    config:
      photo_calib_provider: "input_summary"
      wcs_provider: "input_summary"
  measure:
    class: lsst.pipe.tasks.multiBand.MeasureMergedCoaddSourcesTask
    config:
      connections.refCat: "cal_ref_cat_2_2"
      python: |
        config.match.refObjLoader.filterMap = parameters.filterMap
  matchObjectToTruth:
    class: lsst.pipe.tasks.match_tract_catalog.MatchTractCatalogTask
    config:
      python: |
        # Target settings are likely common to all object tables
        from lsst.pipe.tasks.match_tract_catalog_probabilistic import MatchTractCatalogProbabilisticTask
        config.match_tract_catalog.retarget(MatchTractCatalogProbabilisticTask)
        bands_match = parameters.filterMap.keys()
        fluxes_ref = [
          f"flux_{band}" for bands in (bands_match, parameters.bands_match_fallback) for band in bands
        ]
        config.match_tract_catalog.columns_ref_flux = fluxes_ref
        config.match_tract_catalog.columns_ref_meas = ["ra", "dec"] + fluxes_ref
        fluxes_meas = [f"{band}_cModelFlux" for band in bands_match] + [
            f"{band}_ap12Flux" for band in parameters.bands_match_fallback
        ]
        columns_meas = ["coord_ra", "coord_dec"] + fluxes_meas
        config.match_tract_catalog.columns_target_meas = columns_meas
        config.match_tract_catalog.columns_target_err = [f"{col}Err" for col in columns_meas]
        # Might need adjusting for different survey depths
        config.match_tract_catalog.mag_faintest_ref = 27.0
        config.match_tract_catalog.columns_ref_copy = ["id", "truth_type"]
        config.match_tract_catalog.columns_ref_select_true = ["is_unique_truth_entry"]
        config.match_tract_catalog.columns_target_copy = ["objectId"]
  compareObjectToTruth:
    class: lsst.pipe.tasks.diff_matched_tract_catalog.DiffMatchedTractCatalogTask
    config:
      columns_ref_copy: ["is_pointsource"]
      columns_target_coord_err: ["coord_raErr", "coord_decErr"]
      coord_format.coords_ref_to_convert: {"ra": "x", "dec": "y"}
      # Convert ref ra/dec to x/y but do not measure distances from x/y
      coord_format.return_converted_coords: false
      include_unmatched: true

      python: |
        from lsst.pipe.tasks.diff_matched_tract_catalog import MatchedCatalogFluxesConfig
        columns_flux = {}
        fluxes_meas_psf = []
        for band in parameters.filterMap:
            columns_flux[band] = MatchedCatalogFluxesConfig(
                column_ref_flux=f"flux_{band}",
                columns_target_flux=[f"{band}_cModelFlux",],
                columns_target_flux_err=[f"{band}_cModelFluxErr",],
            )
            fluxes_meas_psf.append(f"{band}_psfFlux")
        config.columns_flux = columns_flux
        # Extendedness columns are needed for downstream plots/metrics/etc.
        columns_target_copy = ["patch", "refExtendedness", "refSizeExtendedness"]
        columns_target_copy.extend(fluxes_meas_psf)
        columns_target_copy.extend([f"{col}Err" for col in fluxes_meas_psf])
        columns_target_copy.extend(["x", "y", "xErr", "yErr"])
        config.columns_target_copy = columns_target_copy
  catalogMatchTract:
    class: lsst.analysis.tools.tasks.astrometricCatalogMatch.AstrometricCatalogMatchTask
    config:
      connections.refCatalog: "cal_ref_cat_2_2"
  photometricCatalogMatch:
    class: lsst.analysis.tools.tasks.photometricCatalogMatch.PhotometricCatalogMatchTask
    config:
      connections.refCatalog: cal_ref_cat_2_2
      connections.matchedCatalog: objectTable_tract_cal_ref_cat_2_2_photoMatch
  refCatObjectTract:
    class: lsst.analysis.tools.tasks.refCatObjectAnalysis.RefCatObjectAnalysisTask
    config:
      connections.refCatalog: "cal_ref_cat_2_2"
  photometricRefCatObjectTract:
    class: lsst.analysis.tools.tasks.refCatObjectPhotometricAnalysis.RefCatObjectPhotometricAnalysisTask
    config:
      connections.data: objectTable_tract_cal_ref_cat_2_2_photoMatch

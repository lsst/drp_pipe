description: DRP specialized for ImSim-DC2 data
instrument: lsst.obs.lsst.LsstCamImSim
imports:
  - location: $DRP_PIPE_DIR/pipelines/_ingredients/DRP.yaml
    labeledSubsetModifyMode: EDIT
    exclude:
     - fgcm
     - gbdesAstrometricFit
  # TODO[DM-47010]: inclusion is historical, possibly unintentional (at least
  # for test-med-1; we want it in ci_imsim for test coverage).  If we don't
  # want it in test-med-1, we should move its inclusion to ci_imsim.
  - $ANALYSIS_TOOLS_DIR/pipelines/coaddDiffMatchedQualityExtended.yaml
parameters:
  filterMap: {
    "u": "lsst_u_smeared",
    "g": "lsst_g_smeared",
    "r": "lsst_r_smeared",
    "i": "lsst_i_smeared",
    "z": "lsst_z_smeared",
    "y": "lsst_y_smeared",
  }
  # Bands to match aperture fluxes on as a fallback if cModel failed
  # default is for highest S/N bands to avoid giving equal weight
  # to aperture fluxes vs CModel (which should be better for galaxies)
  bands_match_fallback: ["r", "i"]
tasks:
  isr:
    class: lsst.ip.isr.IsrTask
    config:
      connections.newBFKernel: bfk
      doDefect: false
      doBrighterFatter: true
      # Although we don't have to apply the amp offset corrections, we do want
      # to compute them for analyzeAmpOffsetMetadata to report on as metrics.
      doAmpOffset: true
      ampOffset.doApplyAmpOffset: false
  calibrate:
    class: lsst.pipe.tasks.calibrate.CalibrateTask
    config:
      connections.astromRefCat: "cal_ref_cat_2_2"
      connections.photoRefCat: "cal_ref_cat_2_2"
      python: |
        config.astromRefObjLoader.filterMap = parameters.filterMap
        config.photoRefObjLoader.filterMap = parameters.filterMap
  updateVisitSummary:
    class: lsst.drp.tasks.update_visit_summary.UpdateVisitSummaryTask
    config:
      photo_calib_provider: "input_summary"
      wcs_provider: "input_summary"
  measure:
    class: lsst.pipe.tasks.multiBand.MeasureMergedCoaddSourcesTask
    config:
      connections.refCat: "cal_ref_cat_2_2"
      python: |
        config.match.refObjLoader.filterMap = parameters.filterMap
  matchObjectToTruth:
    class: lsst.pipe.tasks.match_tract_catalog.MatchTractCatalogTask
    config:
      python: |
        # Target settings are likely common to all object tables
        from lsst.pipe.tasks.match_tract_catalog_probabilistic import MatchTractCatalogProbabilisticTask
        config.match_tract_catalog.retarget(MatchTractCatalogProbabilisticTask)
        bands_match = parameters.filterMap.keys()
        fluxes_ref = [
          f"flux_{band}" for bands in (bands_match, parameters.bands_match_fallback) for band in bands
        ]
        config.match_tract_catalog.columns_ref_flux = fluxes_ref
        config.match_tract_catalog.columns_ref_meas = ["ra", "dec"] + fluxes_ref
        fluxes_meas = [f"{band}_cModelFlux" for band in bands_match] + [
            f"{band}_ap12Flux" for band in parameters.bands_match_fallback
        ]
        columns_meas = ["coord_ra", "coord_dec"] + fluxes_meas
        config.match_tract_catalog.columns_target_meas = columns_meas
        config.match_tract_catalog.columns_target_err = [f"{col}Err" for col in columns_meas]
        # Might need adjusting for different survey depths
        config.match_tract_catalog.mag_faintest_ref = 27.0
        config.match_tract_catalog.columns_ref_copy = ["id", "truth_type"]
        config.match_tract_catalog.columns_ref_select_true = ["is_unique_truth_entry"]
        config.match_tract_catalog.columns_target_copy = ["objectId"]
  compareObjectToTruth:
    class: lsst.pipe.tasks.diff_matched_tract_catalog.DiffMatchedTractCatalogTask
    config:
      columns_ref_copy: ["is_pointsource"]
      columns_target_coord_err: ["coord_raErr", "coord_decErr"]
      coord_format.coords_ref_to_convert: {"ra": "x", "dec": "y"}
      # Convert ref ra/dec to x/y but do not measure distances from x/y
      coord_format.return_converted_coords: false
      include_unmatched: true

      python: |
        from lsst.pipe.tasks.diff_matched_tract_catalog import MatchedCatalogFluxesConfig
        columns_flux = {}
        fluxes_meas_psf = []
        for band in parameters.filterMap:
            columns_flux[band] = MatchedCatalogFluxesConfig(
                column_ref_flux=f"flux_{band}",
                columns_target_flux=[f"{band}_cModelFlux",],
                columns_target_flux_err=[f"{band}_cModelFluxErr",],
            )
            fluxes_meas_psf.append(f"{band}_psfFlux")
        config.columns_flux = columns_flux
        # Extendedness columns are needed for downstream plots/metrics/etc.
        columns_target_copy = ["patch", "refExtendedness", "refSizeExtendedness"]
        columns_target_copy.extend(fluxes_meas_psf)
        columns_target_copy.extend([f"{col}Err" for col in fluxes_meas_psf])
        columns_target_copy.extend(["x", "y", "xErr", "yErr"])
        config.columns_target_copy = columns_target_copy
  catalogMatchTract:
    class: lsst.analysis.tools.tasks.astrometricCatalogMatch.AstrometricCatalogMatchTask
    config:
      connections.refCatalog: "cal_ref_cat_2_2"
  photometricCatalogMatch:
    class: lsst.analysis.tools.tasks.photometricCatalogMatch.PhotometricCatalogMatchTask
    config:
      connections.refCatalog: cal_ref_cat_2_2
      connections.matchedCatalog: objectTable_tract_cal_ref_cat_2_2_photoMatch
  refCatObjectTract:
    class: lsst.analysis.tools.tasks.refCatObjectAnalysis.RefCatObjectAnalysisTask
    config:
      connections.refCatalog: "cal_ref_cat_2_2"
  photometricRefCatObjectTract:
    class: lsst.analysis.tools.tasks.refCatObjectPhotometricAnalysis.RefCatObjectPhotometricAnalysisTask
    config:
      connections.data: objectTable_tract_cal_ref_cat_2_2_photoMatch
subsets:
  # step1 is imported.
  step2:
    subset:
      - consolidatePreSourceTable
      - consolidateVisitSummary
      - isolatedStarAssociation
      - finalizeCharacterization
      - makeCcdVisitTable
      - makeVisitTable
      - updateVisitSummary
      - catalogMatchVisit
      - astrometricRefCatSourceVisit
      - reprocessVisitImage
      - transformSourceTable
      - consolidateSourceTable
      - isolatedStarSourceAssociation
    description: |
      Tasks that can be run together, but only after the 'step1'.

      This is a mix of visit-level, tract-level, and collection-level tasks
      that must be run with a skymap data query constraint only (an instrument
      constraint is fine, but generally unneccessary).  For example, running
      with 'tract' (and 'patch') constraints will select partial visits that
      overlap that region.  A skymap constraint is necessary to prevent
      isolatedStarAssociation from producing results for all skymaps in the
      data repository.

      Visit-level tasks include consolidatePreSourceTable,
      consolidateVisitSummary, finalizeCharacterization, updateVisitSummary.
      Tract-level tasks include: isolatedStarAssociation
      Full collection-level tasks include: makeCcdVisitTable, makeVisitTable
  # step3 is imported.
  # step4 is imported.
  # step5 is imported.
  step6:
    subset:
      - consolidateDiaSourceTable
      - sourceObjectMatch
    description: |
      Tasks that can be run together, but only after the 'step1', 'step2',
      'step3', and 'step4' subsets

      This step includes visit-level aggregation tasks. Running without tract
      or patch in the data query is recommended, otherwise the outputs of
      consolidateDiaSourceTable will not contain complete visits.

      This subset is separate from step4 to signal to operators to pause to
      assess unexpected image differencing failures before these aggregation
      steps. Otherwise, if run in the same quantum graph, aggregated data
      products (e.g. diaObjects) would not be created if one or more of the
      expected inputs is missing.
  step7:
    subset:
      - consolidateHealSparsePropertyMaps
      - analyzeObjectTableSurveyCore
    description: |
      Tasks that should be run as the final step that require global inputs,
      and can be run after the 'step3' subset.

      This step has global aggregation tasks to run over all visits, detectors,
      tracts, etc.  This step should be run only with the instrument constraint
      in the data query.

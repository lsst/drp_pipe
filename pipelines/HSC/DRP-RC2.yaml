description: The DRP pipeline specialized for the HSC RC2 dataset.
instrument: lsst.obs.subaru.HyperSuprimeCam
imports:
  - location: $DRP_PIPE_DIR/ingredients/DRP.yaml
    exclude:
      - writeSourceTable  # cannot reconfigure because different dimensions.
  - location: $FARO_DIR/pipelines/metrics_pipeline_jointcal_fgcm.yaml
  - location: $ANALYSIS_DRP_DIR/pipelines/analysis_drp_plots.yaml
tasks:
  skyCorr:
    class: lsst.pipe.tasks.skyCorrection.SkyCorrectionTask
  isolatedStarAssociation:
    class: lsst.pipe.tasks.isolatedStarAssociation.IsolatedStarAssociationTask
    config:
      band_order: ["i", "r", "g", "z", "y", "N921"]
      connections.source_table_visit: preSourceTable_visit
  jointcal:
    # Running jointcal is something we want to do for all real-world
    # instruments, so it doesn't belong in an HSC-specific pipeline, let alone
    # an RC2-specific one.  We just haven't done the pipeline refactoring that
    # would fix this.
    class: lsst.jointcal.JointcalTask
    config:
      connections.inputSourceTableVisit: preSourceTable_visit
  # The FGCM configurations below are appropriate specifically for RC2; this is
  # not a bad place for it, because we don't have (and may never have)
  # configuration for FGCM that works across arbitrary datasets; it depends too
  # much on what filters are in play.  But it still might make sense to
  # refactor the configurations below into separate (but still RC2-specific)
  # config files.
  fgcmBuildStarsTable:
    class: lsst.fgcmcal.fgcmBuildStarsTable.FgcmBuildStarsTableTask
    config:
      minPerBand: 1
      densityCutMaxPerPixel: 1500
      primaryBands: ["i", "r", "g", "z", "y", "N921"]
      doReferenceMatches: true
      randomSeed: 23456
      connections.sourceTable_visit: preSourceTable_visit
  fgcmFitCycle:
    class: lsst.fgcmcal.fgcmFitCycle.FgcmFitCycleTask
    config:
      doMultipleCycles: true
      multipleCyclesFinalCycleNumber: 4
      randomSeed: 89234
      outfileBase: "fgcmFitCycleRC2"
      bands: ["g", "r", "i", "z", "N921", "y"]
      fitBands: ["g", "r", "i", "z", "N921", "y"]
      maxIterBeforeFinalCycle: 50
      expGrayPhotometricCutDict:
        g: -0.05
        r: -0.05
        i: -0.05
        z: -0.05
        N921: -0.05
        y: -0.05
      expGrayHighCutDict:
        g: 0.10
        r: 0.10
        i: 0.10
        z: 0.10
        N921: 0.10
        y: 0.10
      aperCorrFitNBins: 0
      minStarPerExp: 100
      expVarGrayPhotometricCutDict:
        g: 0.0025
        r: 0.0025
        i: 0.0025
        z: 0.0025
        N921: 0.005
        y: 0.0025
      minExpPerNight: 3
      deltaAperInnerRadiusArcsec: 2.04
      deltaAperOuterRadiusArcsec: 2.89
      python: |
        from lsst.fgcmcal import Sedterm, Sedboundaryterm
        config.sedboundaryterms.data = {'gr': Sedboundaryterm(primary='g', secondary='r'),
                                        'ri': Sedboundaryterm(primary='r', secondary='i'),
                                        'iz': Sedboundaryterm(primary='i', secondary='z'),
                                        'zy': Sedboundaryterm(primary='z', secondary='y'),
                                        'N921z': Sedboundaryterm(primary='N921', secondary='z')}
        config.sedterms.data = {'g': Sedterm(primaryTerm='gr', secondaryTerm='ri', constant=1.6),
                                'r': Sedterm(primaryTerm='gr', secondaryTerm='ri', constant=0.9),
                                'i': Sedterm(primaryTerm='ri', secondaryTerm='iz', constant=1.0),
                                'z': Sedterm(primaryTerm='iz', secondaryTerm='zy', constant=1.0),
                                'y': Sedterm(primaryTerm='zy', secondaryTerm='iz', constant=0.25,
                                             extrapolated=True, primaryBand='y', secondaryBand='z',
                                             tertiaryBand='i'),
                                'N921': Sedterm(primaryTerm='N921z', constant=0.5)}
  fgcmOutputProducts:
    class: lsst.fgcmcal.fgcmOutputProducts.FgcmOutputProductsTask
    config:
      cycleNumber: 4
  writePreSourceTable:
    class: lsst.pipe.tasks.postprocess.WriteSourceTableTask
    config:
      connections.outputCatalog: preSource
  transformPreSourceTable:
    class: lsst.pipe.tasks.postprocess.TransformSourceTableTask
    config:
      connections.inputCatalog: preSource
      connections.outputCatalog: preSourceTable
  consolidatePreSourceTable:
    class: lsst.pipe.tasks.postprocess.ConsolidateSourceTableTask
    config:
      connections.inputCatalogs: preSourceTable
      connections.outputCatalog: preSourceTable_visit
  updateVisitSummary:
    class: lsst.pipe.tasks.update_visit_summary.UpdateVisitSummaryTask
    config:
      wcs_provider: "tract"
      photo_calib_provider: "global"
      background_provider: "replacement"
  writeRecalibratedSourceTable:
    class: lsst.pipe.tasks.postprocess.WriteRecalibratedSourceTableTask
    config:
      connections.outputCatalog: source
  measure:
    class: lsst.pipe.tasks.multiBand.MeasureMergedCoaddSourcesTask
    config:
      connections.sourceTableHandles: preSourceTable_visit
subsets:
  fgcm:
    subset:
      - fgcmBuildStarsTable
      - fgcmFitCycle
      - fgcmOutputProducts
    description: |
      Subset that includes all FGCM tasks.
  singleFrame:
    subset:
      - isr
      - characterizeImage
      - calibrate
      - writePreSourceTable
      - transformPreSourceTable
      - consolidatePreSourceTable
      - consolidateVisitSummary
      - skyCorr
      - isolatedStarAssociation
    description: |
      Set of tasks for complete single frame processing. Analogous to
      SingleFrameDriver.
  multiVisit:
    subset: []
    description: |
      The multiVisit subset defined in pipe_tasks' DRP.yaml is not safe to
      use on HSC for various reasons; use 'step1', 'step2', and 'step3' subsets
      instead.  It may be re-enabled in the future.
  step1:
    subset:
      - isr
      - characterizeImage
      - calibrate
      - writePreSourceTable
      - transformPreSourceTable
    description: |
      Per-detector tasks that can be run together to start the DRP pipeline.

      These should never be run with 'tract' or 'patch' as part of the data ID
      expression if any later steps will also be run, because downstream steps
      require full visits and 'tract' and 'patch' constraints will always
      select partial visits that overlap that region.
  step2a:
    subset:
      - consolidatePreSourceTable
      - consolidateVisitSummary
      - skyCorr
      - isolatedStarAssociation
    description: |
      Global tasks: This is a mix of visit-level and tract-level tasks that
      must be run with a skymap data query constraint only (an instrument
      constraint is fine, but generally unneccessary).  For example, running
      with 'tract' (and 'patch') constraints will select partial visits that
      overlap that region.  A skymap constraint is necessary to prevent
      isolatedStarAssociation from producing results for all skymaps in the
      data repository. This only works with small to medium jobs.  Use DRP-Prod
      for large production subsets.

      skyCorr requires full visits, and 'tract' and 'patch'
      constraints will always select partial visits that overlap that region.

      Visit-level: consolidatePreSourceTable, consolidateVisitSummary,
      skyCorr
      Tract-level: isolatedStarAssociation
  step2b:
    subset:
      - jointcal
    description: |
      Per-tract steps that must be run after step2a.

      These should be run with explicit 'tract' constraints essentially all the
      time, because otherwise quanta will be created for jobs with only partial
      visit coverage.

      This subset is considered a workaround for missing middleware and task
      functionality.  It may be removed in the future.
  step2cde:
    subset:
      - finalizeCharacterization
      - fgcmBuildStarsTable
      - fgcmFitCycle
      - fgcmOutputProducts
      - updateVisitSummary
      - makeCcdVisitTable
      - makeVisitTable
    description: |
      Per-visit and per-collection tasks that can be run together after step2b
      with no data query constraints other than instrument.

      FGCM requires full visits and 'tract' and 'patch' constraints will
      always select partial visits that overlap that region.

      This includes FGCM because it's configured here to run in "global" mode,
      which means one should not use a 'tract' expression to constrain it, and
      if one _did_ run it with a tract constraint (which would be a common
      occurrence if it was included in any later step), it would be fed the
      wrong (partial-visit) inputs to its 'background' connection.
  step3:
    subset:
      - makeWarp
      - assembleCoadd
      - detection
      - mergeDetections
      - deblend
      - measure
      - mergeMeasurements
      - forcedPhotCoadd
      - transformObjectTable
      - writeObjectTable
      - consolidateObjectTable
      - healSparsePropertyMaps
      - selectGoodSeeingVisits
      - templateGen
    description: |
      Tasks that can be run together, but only after the 'step1' and 'step2'
      subsets.

      These should be run with explicit 'tract' constraints essentially all the
      time, because otherwise quanta will be created for jobs with only partial
      visit coverage.

      This subset is considered a workaround for missing middleware and task
      functionality.  It may be removed in the future.
  step4:
    subset:
      - forcedPhotCcd
      - forcedPhotDiffim
      - getTemplate
      - imageDifference
      - transformDiaSourceCat
      - writeForcedSourceTable
      - writeRecalibratedSourceTable
      - transformSourceTable
    description: |
      Tasks that can be run together, but only after the 'step1', 'step2' and
      'step3' subsets

      These detector-level tasks should not be run with 'tract' or 'patch' as
      part of the data ID expression if all reference catalogs or diffIm
      templates that cover these detector-level quanta are desired.
  step5:
    subset:
      - drpAssociation
      - drpDiaCalculation
      - forcedPhotCcdOnDiaObjects
      - forcedPhotDiffOnDiaObjects
      - transformForcedSourceTable
      - consolidateForcedSourceTable
      - consolidateAssocDiaSourceTable
      - consolidateFullDiaObjectTable
      - writeForcedSourceOnDiaObjectTable
      - transformForcedSourceOnDiaObjectTable
      - consolidateForcedSourceOnDiaObjectTable
    description: |
      Tasks that can be run together, but only after the 'step1', 'step2',
      'step3', and 'step4' subsets

      This step includes patch-level aggregation Tasks. These should be run
      with explicit 'tract' constraints in the data query, otherwise quanta
      will be created for jobs with only partial visit coverage.
      'consolidateForcedSourceTable' is a tract-level task that aggregates
      patches and should be rerun if any of the patches fail.
  step6:
    subset:
      - consolidateDiaSourceTable
      - consolidateSourceTable
    description: |
      Tasks that can be run together, but only after the 'step1', 'step2',
      'step3', and 'step4', 'step5' subsets

      This step includes visit-level aggregation tasks. Running without tract
      or patch in the data query is recommended, otherwise the outputs of
      consolidateDiaSourceTable, and consolidateSourceTable
      will not contain complete visits.

      This subset is separate from step4 to signal to operators to pause to
      assess unexpected image differencing failures before these aggregation
      steps. Otherwise, if run in the same quantum graph, aggregated data
      products (e.g. diaObjects) would not be created if one or more of the
      expected inputs is missing.
  step7:
    subset:
      - consolidateHealSparsePropertyMaps
    description: |
      Tasks that should be run as the final step that require global inputs,
      and can be run after the 'step3' subset.

      This step has global aggregation tasks to run over all visits, detectors,
      tracts, etc.  This step should be run only with the instrument constraint
      in the data query.
  faro_all:
    subset:
      # visit-level on single-frame products
      - nsrcMeasVisit
      - TE3
      - TE4
      # tract-level, matched-visit on single-frame products
      - matchCatalogsTract
      - matchCatalogsPatch
      - matchCatalogsPatchMultiBand
      - matchCatalogsTractMag17to21p5
      - matchCatalogsTractStarsSNR5to80
      - matchCatalogsTractGxsSNR5to80
      - PA1
      - PF1_design
      - AM1
      - AM2
      - AM3
      - AD1_design
      - AD2_design
      - AD3_design
      - AF1_design
      - AF2_design
      - AF3_design
      - AB1
      - modelPhotRepGal1
      - modelPhotRepGal2
      - modelPhotRepGal3
      - modelPhotRepGal4
      - modelPhotRepStar1
      - modelPhotRepStar2
      - modelPhotRepStar3
      - modelPhotRepStar4
      - psfPhotRepStar1
      - psfPhotRepStar2
      - psfPhotRepStar3
      - psfPhotRepStar4
      # tract-level on coadd products
      - TE1
      - TE2
      - wPerp
      - skyObjectMean
      - skyObjectStd
    description: |
      Set of tasks for calculation of metrics via faro.
      These tasks are a mix of visit- and tract-level and must be run globally
      for RC2.
      Tasks that require single-frame products use Calibrated Source Tables,
      which are available after consolidateSourceTable (step6) is run.
      Tasks that require coadd products use Object Tables which are available
      after consolidateObjectTable (step3) is run.
